---
title: "Spiny Lobster Management"
resource_files:
- LobsterManagementAreas.cpg
- LobsterManagementAreas.shx
- LobsterManagementAreas.dbf
- LobsterManagementAreas.prj
- LobsterManagementAreas.sbn
- LobsterManagementAreas.sbx
- LobsterManagementAreas.shp.xml
runtime: shiny
output:
  flexdashboard::flex_dashboard:
    social: menu
    source_code: embed
---

```{r setup, include=FALSE}
library(flexdashboard)
library(devtools)
library(leaflet)
library(highcharter)
library(markdown)
library(shiny)
library(rgdal)
# devtools::install_github("rstudio/flexdashboard", ref="bugfix/dashboard-init-after-body")

lobPoly <- readOGR(dsn="LobsterManagementAreas.shp",layer="LobsterManagementAreas")
proj4string(lobPoly) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")

geoTest <- readOGR(dsn="geoTest.shp",layer="geoTest")
proj4string(geoTest) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
```

<!-- Column {data-width=650} -->
<!----------------------------------------------------------------------->

### Lobster Trap Closed Areas

```{r}


fillCol(height = 600,flex = 1,
  leafletOutput('map', width = "100%", height="100%")
)

tags$script('
              $(document).ready(function () {

                function getLocation(callback){
                var options = {
                enableHighAccuracy: true,
                timeout: 5000,
                maximumAge: 0
                };

                navigator.geolocation.getCurrentPosition(onSuccess, onError);

                function onError (err) {
                Shiny.onInputChange("geolocation", false);
                }

                function onSuccess (position) {
                setTimeout(function () {
                var coords = position.coords;
                var timestamp = new Date();

                console.log(coords.latitude + ", " + coords.longitude, "," + coords.accuracy);
                Shiny.onInputChange("geolocation", true);
                Shiny.onInputChange("lat", coords.latitude);
                Shiny.onInputChange("long", coords.longitude);
                Shiny.onInputChange("accuracy", coords.accuracy);
                Shiny.onInputChange("time", timestamp)

                console.log(timestamp);

                if (callback) {
                callback();
                }
                }, 1100)
                }
                }

                var TIMEOUT = 100000; //SPECIFY
                var started = false;
                function getLocationRepeat(){
                //first time only - no delay needed
                if (!started) {
                started = true;
                getLocation(getLocationRepeat);
                return;
                }

                setTimeout(function () {
                getLocation(getLocationRepeat);
                }, TIMEOUT);

                };

                getLocationRepeat();

                });
                ')
verbatimTextOutput("lat")
verbatimTextOutput("long")
verbatimTextOutput("geolocation")
verbatimTextOutput("accuracy")

output$map <- renderLeaflet({  

  
       map <- leaflet() %>% 
     
            addTiles('http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
               options = providerTileOptions(noWrap = TRUE)) %>%
      addTiles('http://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/Mapserver/tile/{z}/{y}/{x}',
               options = providerTileOptions(noWrap = TRUE)) %>%

                 setView(-79.61663461, 27.7623829, zoom = 6) %>% 
         #addPolygons(data=lobPoly, color="yellow",stroke=FALSE, fillOpacity=1.0,layerId=~ET_ID)
         addPolygons(data=geoTest, color="yellow",stroke=FALSE, fillOpacity=1.0,layerId=~id)
       })

observe({
  geo <- input$geolocation
  
  if (is.null(geo))
    return ()
  
  lat <- input$lat
  lon <- input$long

      #puts lat and lon for click point into its own data frame
      coords <- as.data.frame(cbind(lon, lat))

      #converts click point coordinate data frame into SP object, sets CRS
      point <- SpatialPoints(coords)
      proj4string(point) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")

      #retrieves country in which the click point resides, set CRS for country
      selected <- geoTest[point,]
      proj4string(selected) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")

      proxy <- leafletProxy("map")
      if(geoTest$id == "Selected"){
        proxy %>% removeShape(layerId = "Selected")
      } else {
        proxy %>% addPolygons(data = selected,
                              fillColor = "red",
                              fillOpacity = 1,
                              color = "red",

                              stroke = FALSE,
                              layerId = "Selected")
      }
  
  
  
  
  
  
})

# observeEvent(input$map_shape_click, {
#       click <- input$map_shape_click
# 
#       if(is.null(click))
#         return()
# 
#       #pulls lat and lon from shiny click event
#       lat <- click$lat
#       lon <- click$lng
# 
#       #puts lat and lon for click point into its own data frame
#       coords <- as.data.frame(cbind(lon, lat))
# 
#       #converts click point coordinate data frame into SP object, sets CRS
#       point <- SpatialPoints(coords)
#       proj4string(point) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
# 
#       #retrieves country in which the click point resides, set CRS for country
#       selected <- lobPoly[point,]
#       proj4string(selected) <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
# 
#       proxy <- leafletProxy("map")
#       if(click$id == "Selected"){
#         proxy %>% removeShape(layerId = "Selected")
#       } else {
#         proxy %>% addPolygons(data = selected,
#                               fillColor = "red",
#                               fillOpacity = 1,
#                               color = "red",
# 
#                               stroke = FALSE,
#                               layerId = "Selected")
#       }
#     })

output$lat <- renderPrint({
    input$lat
  }) ## renderPrint

  output$long <- renderPrint({
    input$long
  }) ## renderPrint

  output$geolocation <- renderPrint({
    input$geolocation
  }) ## renderPrint

  output$accuracy <- renderPrint({
    input$accuracy
  })

  output$time <- renderPrint({
    input$time
  })

  ###observer to change map based on location##

  observe({
    if(!is.null(input$lat)){
      map <- leafletProxy("map")
      dist <- 0.5
      lat <- input$lat
      lng <- input$long
      map %>% fitBounds(lng - dist, lat - dist, lng + dist, lat + dist) %>%
      #addMarkers(-81.41, 26.15) %>%
        addMarkers(lng,lat) #%>%
        # addRectangles(lng1=  -82.517131, lat1=27.963717,
        #               lng2=-82.511541, lat2=27.959590,
        #               fillColor="#dd1c77", fillOpacity = 1,
        #               color = "#dd1c77") %>%
        # addRectangles(lng1=  -82.635620, lat1=27.956195,
        #               lng2=-82.597855, lat2=27.932922,
        #               fillColor="#dd1c77", fillOpacity = 1,
        #               color = "#dd1c77")
    }
  })


```

<!--Column {data-width=350}-->
<!----------------------------------------------------------------------->

<!--### Lobster Trap Closed Areas {.mobile}
```{r}
fillCol(height = 600,flex = 1,
  leafletOutput('map2', width = "100%", height="100%")
)

output$map2 <- renderLeaflet({  

  
       map2 <- leaflet() %>% 
     
            addTiles('http://server.arcgisonline.com/ArcGIS/rest/services/Ocean_Basemap/MapServer/tile/{z}/{y}/{x}',
                     options = list(providerTileOptions(noWrap = TRUE)) ) %>%

                 setView(-79.61663461, 27.7623829, zoom = 6)})
  

```
-->



